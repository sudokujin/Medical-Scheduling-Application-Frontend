{"ast":null,"code":"import _slicedToArray from \"/Users/kwon/Desktop/repo/Medical-Scheduling-Application-Frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/kwon/Desktop/repo/Medical-Scheduling-Application-Frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport { getOverlapGroupHandler, getVisuals, hasOverlap, getNormalizedRange } from './common';\nimport { getTimestampIdentifier } from '../util/timestamp';\nvar FULL_WIDTH = 100;\nvar DEFAULT_OFFSET = 5;\nvar WIDTH_MULTIPLIER = 1.7;\n/**\n * Variation of column mode where events can be stacked. The priority of this\n * mode is to stack events together taking up the least amount of space while\n * trying to ensure the content of the event is always visible as well as its\n * start and end. A sibling column has intersecting event content and must be\n * placed beside each other. Non-sibling columns are offset by 5% from the\n * previous column. The width is scaled by 1.7 so the events overlap and\n * whitespace is reduced. If there is a hole in columns the event width is\n * scaled up so it intersects with the next column. The columns have equal\n * width in the space they are given. If the event doesn't have any to the\n * right of it that intersect with it's content it's right side is extended\n * to the right side.\n */\n\nexport var stack = function stack(events, firstWeekday, overlapThreshold) {\n  var handler = getOverlapGroupHandler(firstWeekday); // eslint-disable-next-line max-statements\n\n  return function (day, dayEvents, timed, reset) {\n    if (!timed) {\n      return handler.getVisuals(day, dayEvents, timed, reset);\n    }\n    var dayStart = getTimestampIdentifier(day);\n    var visuals = getVisuals(dayEvents, dayStart);\n    var groups = getGroups(visuals, dayStart);\n    var _iterator = _createForOfIteratorHelper(groups),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var group = _step.value;\n        var nodes = [];\n        var _iterator2 = _createForOfIteratorHelper(group.visuals),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var visual = _step2.value;\n            var child = getNode(visual, dayStart);\n            var index = getNextIndex(child, nodes);\n            if (index === false) {\n              var parent = getParent(child, nodes);\n              if (parent) {\n                child.parent = parent;\n                child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold));\n                child.index = parent.index + 1;\n                parent.children.push(child);\n              }\n            } else {\n              var _getOverlappingRange = getOverlappingRange(child, nodes, index - 1, index - 1),\n                _getOverlappingRange2 = _slicedToArray(_getOverlappingRange, 1),\n                _parent = _getOverlappingRange2[0];\n              var children = getOverlappingRange(child, nodes, index + 1, index + nodes.length, true);\n              child.children = children;\n              child.index = index;\n              if (_parent) {\n                child.parent = _parent;\n                child.sibling = hasOverlap(child.start, child.end, _parent.start, addTime(_parent.start, overlapThreshold));\n                _parent.children.push(child);\n              }\n              var _iterator3 = _createForOfIteratorHelper(children),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var grand = _step3.value;\n                  if (grand.parent === _parent) {\n                    grand.parent = child;\n                  }\n                  var grandNext = grand.index - child.index <= 1;\n                  if (grandNext && child.sibling && hasOverlap(child.start, addTime(child.start, overlapThreshold), grand.start, grand.end)) {\n                    grand.sibling = true;\n                  }\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n            nodes.push(child);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        calculateBounds(nodes, overlapThreshold);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    visuals.sort(function (a, b) {\n      return a.left - b.left || a.event.startTimestampIdentifier - b.event.startTimestampIdentifier;\n    });\n    return visuals;\n  };\n};\nfunction calculateBounds(nodes, overlapThreshold) {\n  var _iterator4 = _createForOfIteratorHelper(nodes),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var node = _step4.value;\n      var visual = node.visual,\n        parent = node.parent;\n      var columns = getMaxChildIndex(node) + 1;\n      var spaceLeft = parent ? parent.visual.left : 0;\n      var spaceWidth = FULL_WIDTH - spaceLeft;\n      var offset = Math.min(DEFAULT_OFFSET, FULL_WIDTH / columns);\n      var columnWidthMultiplier = getColumnWidthMultiplier(node, nodes);\n      var columnOffset = spaceWidth / (columns - node.index + 1);\n      var columnWidth = spaceWidth / (columns - node.index + (node.sibling ? 1 : 0)) * columnWidthMultiplier;\n      if (parent) {\n        visual.left = node.sibling ? spaceLeft + columnOffset : spaceLeft + offset;\n      }\n      visual.width = hasFullWidth(node, nodes, overlapThreshold) ? FULL_WIDTH - visual.left : Math.min(FULL_WIDTH - visual.left, columnWidth * WIDTH_MULTIPLIER);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}\nfunction getColumnWidthMultiplier(node, nodes) {\n  if (!node.children.length) {\n    return 1;\n  }\n  var maxColumn = node.index + nodes.length;\n  var minColumn = node.children.reduce(function (min, c) {\n    return Math.min(min, c.index);\n  }, maxColumn);\n  return minColumn - node.index;\n}\nfunction getOverlappingIndices(node, nodes) {\n  var indices = [];\n  var _iterator5 = _createForOfIteratorHelper(nodes),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var other = _step5.value;\n      if (hasOverlap(node.start, node.end, other.start, other.end)) {\n        indices.push(other.index);\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return indices;\n}\nfunction getNextIndex(node, nodes) {\n  var indices = getOverlappingIndices(node, nodes);\n  indices.sort();\n  for (var i = 0; i < indices.length; i++) {\n    if (i < indices[i]) {\n      return i;\n    }\n  }\n  return false;\n}\nfunction getOverlappingRange(node, nodes, indexMin, indexMax) {\n  var returnFirstColumn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var overlapping = [];\n  var _iterator6 = _createForOfIteratorHelper(nodes),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var other = _step6.value;\n      if (other.index >= indexMin && other.index <= indexMax && hasOverlap(node.start, node.end, other.start, other.end)) {\n        overlapping.push(other);\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  if (returnFirstColumn && overlapping.length > 0) {\n    var first = overlapping.reduce(function (min, n) {\n      return Math.min(min, n.index);\n    }, overlapping[0].index);\n    return overlapping.filter(function (n) {\n      return n.index === first;\n    });\n  }\n  return overlapping;\n}\nfunction getParent(node, nodes) {\n  var parent = null;\n  var _iterator7 = _createForOfIteratorHelper(nodes),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var other = _step7.value;\n      if (hasOverlap(node.start, node.end, other.start, other.end) && (parent === null || other.index > parent.index)) {\n        parent = other;\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return parent;\n}\nfunction hasFullWidth(node, nodes, overlapThreshold) {\n  var _iterator8 = _createForOfIteratorHelper(nodes),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var other = _step8.value;\n      if (other !== node && other.index > node.index && hasOverlap(node.start, addTime(node.start, overlapThreshold), other.start, other.end)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  return true;\n}\nfunction getGroups(visuals, dayStart) {\n  var groups = [];\n  var _iterator9 = _createForOfIteratorHelper(visuals),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var visual = _step9.value;\n      var _getNormalizedRange = getNormalizedRange(visual.event, dayStart),\n        _getNormalizedRange2 = _slicedToArray(_getNormalizedRange, 2),\n        start = _getNormalizedRange2[0],\n        end = _getNormalizedRange2[1];\n      var added = false;\n      var _iterator10 = _createForOfIteratorHelper(groups),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var group = _step10.value;\n          if (hasOverlap(start, end, group.start, group.end)) {\n            group.visuals.push(visual);\n            group.end = Math.max(group.end, end);\n            added = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      if (!added) {\n        groups.push({\n          start: start,\n          end: end,\n          visuals: [visual]\n        });\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  return groups;\n}\nfunction getNode(visual, dayStart) {\n  var _getNormalizedRange3 = getNormalizedRange(visual.event, dayStart),\n    _getNormalizedRange4 = _slicedToArray(_getNormalizedRange3, 2),\n    start = _getNormalizedRange4[0],\n    end = _getNormalizedRange4[1];\n  return {\n    parent: null,\n    sibling: true,\n    index: 0,\n    visual: visual,\n    start: start,\n    end: end,\n    children: []\n  };\n}\nfunction getMaxChildIndex(node) {\n  var max = node.index;\n  var _iterator11 = _createForOfIteratorHelper(node.children),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var child = _step11.value;\n      var childMax = getMaxChildIndex(child);\n      if (childMax > max) {\n        max = childMax;\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  return max;\n}\nfunction addTime(identifier, minutes) {\n  var removeMinutes = identifier % 100;\n  var totalMinutes = removeMinutes + minutes;\n  var addHours = Math.floor(totalMinutes / 60);\n  var addMinutes = totalMinutes % 60;\n  return identifier - removeMinutes + addHours * 100 + addMinutes;\n}","map":{"version":3,"names":["getOverlapGroupHandler","getVisuals","hasOverlap","getNormalizedRange","getTimestampIdentifier","FULL_WIDTH","DEFAULT_OFFSET","WIDTH_MULTIPLIER","stack","events","firstWeekday","overlapThreshold","handler","day","dayEvents","timed","reset","dayStart","visuals","groups","getGroups","_iterator","_createForOfIteratorHelper","_step","s","n","done","group","value","nodes","_iterator2","_step2","visual","child","getNode","index","getNextIndex","parent","getParent","sibling","start","end","addTime","children","push","_getOverlappingRange","getOverlappingRange","_getOverlappingRange2","_slicedToArray","length","_iterator3","_step3","grand","grandNext","err","e","f","calculateBounds","sort","a","b","left","event","startTimestampIdentifier","_iterator4","_step4","node","columns","getMaxChildIndex","spaceLeft","spaceWidth","offset","Math","min","columnWidthMultiplier","getColumnWidthMultiplier","columnOffset","columnWidth","width","hasFullWidth","maxColumn","minColumn","reduce","c","getOverlappingIndices","indices","_iterator5","_step5","other","i","indexMin","indexMax","returnFirstColumn","arguments","undefined","overlapping","_iterator6","_step6","first","filter","_iterator7","_step7","_iterator8","_step8","_iterator9","_step9","_getNormalizedRange","_getNormalizedRange2","added","_iterator10","_step10","max","_getNormalizedRange3","_getNormalizedRange4","_iterator11","_step11","childMax","identifier","minutes","removeMinutes","totalMinutes","addHours","floor","addMinutes"],"sources":["../../../../src/components/VCalendar/modes/stack.ts"],"sourcesContent":["import { CalendarEventOverlapMode, CalendarEventVisual } from 'vuetify/types'\nimport { getOverlapGroupHandler, getVisuals, hasOverlap, getNormalizedRange } from './common'\nimport { getTimestampIdentifier } from '../util/timestamp'\n\ninterface Group {\n  start: number\n  end: number\n  visuals: CalendarEventVisual[]\n}\n\ninterface Node {\n  parent: Node | null\n  sibling: boolean\n  index: number\n  visual: CalendarEventVisual\n  start: number\n  end: number\n  children: Node[]\n}\n\nconst FULL_WIDTH = 100\n\nconst DEFAULT_OFFSET = 5\n\nconst WIDTH_MULTIPLIER = 1.7\n\n/**\n * Variation of column mode where events can be stacked. The priority of this\n * mode is to stack events together taking up the least amount of space while\n * trying to ensure the content of the event is always visible as well as its\n * start and end. A sibling column has intersecting event content and must be\n * placed beside each other. Non-sibling columns are offset by 5% from the\n * previous column. The width is scaled by 1.7 so the events overlap and\n * whitespace is reduced. If there is a hole in columns the event width is\n * scaled up so it intersects with the next column. The columns have equal\n * width in the space they are given. If the event doesn't have any to the\n * right of it that intersect with it's content it's right side is extended\n * to the right side.\n */\n\nexport const stack: CalendarEventOverlapMode = (events, firstWeekday, overlapThreshold) => {\n  const handler = getOverlapGroupHandler(firstWeekday)\n\n  // eslint-disable-next-line max-statements\n  return (day, dayEvents, timed, reset) => {\n    if (!timed) {\n      return handler.getVisuals(day, dayEvents, timed, reset)\n    }\n\n    const dayStart = getTimestampIdentifier(day)\n    const visuals = getVisuals(dayEvents, dayStart)\n    const groups = getGroups(visuals, dayStart)\n\n    for (const group of groups) {\n      const nodes: Node[] = []\n\n      for (const visual of group.visuals) {\n        const child = getNode(visual, dayStart)\n        const index = getNextIndex(child, nodes)\n\n        if (index === false) {\n          const parent = getParent(child, nodes)\n          if (parent) {\n            child.parent = parent\n            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold))\n            child.index = parent.index + 1\n            parent.children.push(child)\n          }\n        } else {\n          const [parent] = getOverlappingRange(child, nodes, index - 1, index - 1)\n          const children = getOverlappingRange(child, nodes, index + 1, index + nodes.length, true)\n\n          child.children = children\n          child.index = index\n\n          if (parent) {\n            child.parent = parent\n            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold))\n            parent.children.push(child)\n          }\n\n          for (const grand of children) {\n            if (grand.parent === parent) {\n              grand.parent = child\n            }\n\n            const grandNext = grand.index - child.index <= 1\n            if (grandNext && child.sibling &&\n              hasOverlap(child.start, addTime(child.start, overlapThreshold), grand.start, grand.end)) {\n              grand.sibling = true\n            }\n          }\n        }\n\n        nodes.push(child)\n      }\n\n      calculateBounds(nodes, overlapThreshold)\n    }\n\n    visuals.sort((a, b) => (a.left - b.left) || (a.event.startTimestampIdentifier - b.event.startTimestampIdentifier))\n\n    return visuals\n  }\n}\n\nfunction calculateBounds (nodes: Node[], overlapThreshold: number) {\n  for (const node of nodes) {\n    const { visual, parent } = node\n    const columns = getMaxChildIndex(node) + 1\n    const spaceLeft = parent ? parent.visual.left : 0\n    const spaceWidth = FULL_WIDTH - spaceLeft\n    const offset = Math.min(DEFAULT_OFFSET, FULL_WIDTH / columns)\n    const columnWidthMultiplier = getColumnWidthMultiplier(node, nodes)\n    const columnOffset = spaceWidth / (columns - node.index + 1)\n    const columnWidth = spaceWidth / (columns - node.index + (node.sibling ? 1 : 0)) * columnWidthMultiplier\n\n    if (parent) {\n      visual.left = node.sibling\n        ? spaceLeft + columnOffset\n        : spaceLeft + offset\n    }\n\n    visual.width = hasFullWidth(node, nodes, overlapThreshold)\n      ? FULL_WIDTH - visual.left\n      : Math.min(FULL_WIDTH - visual.left, columnWidth * WIDTH_MULTIPLIER)\n  }\n}\n\nfunction getColumnWidthMultiplier (node: Node, nodes: Node[]): number {\n  if (!node.children.length) {\n    return 1\n  }\n\n  const maxColumn = node.index + nodes.length\n  const minColumn = node.children.reduce((min, c) => Math.min(min, c.index), maxColumn)\n\n  return minColumn - node.index\n}\n\nfunction getOverlappingIndices (node: Node, nodes: Node[]): number[] {\n  const indices: number[] = []\n  for (const other of nodes) {\n    if (hasOverlap(node.start, node.end, other.start, other.end)) {\n      indices.push(other.index)\n    }\n  }\n  return indices\n}\n\nfunction getNextIndex (node: Node, nodes: Node[]): number | false {\n  const indices = getOverlappingIndices(node, nodes)\n  indices.sort()\n\n  for (let i = 0; i < indices.length; i++) {\n    if (i < indices[i]) {\n      return i\n    }\n  }\n  return false\n}\n\nfunction getOverlappingRange (node: Node, nodes: Node[], indexMin: number, indexMax: number, returnFirstColumn = false): Node[] {\n  const overlapping: Node[] = []\n  for (const other of nodes) {\n    if (other.index >= indexMin && other.index <= indexMax && hasOverlap(node.start, node.end, other.start, other.end)) {\n      overlapping.push(other)\n    }\n  }\n  if (returnFirstColumn && overlapping.length > 0) {\n    const first = overlapping.reduce((min, n) => Math.min(min, n.index), overlapping[0].index)\n    return overlapping.filter(n => n.index === first)\n  }\n  return overlapping\n}\n\nfunction getParent (node: Node, nodes: Node[]): Node | null {\n  let parent: Node | null = null\n  for (const other of nodes) {\n    if (hasOverlap(node.start, node.end, other.start, other.end) && (parent === null || other.index > parent.index)) {\n      parent = other\n    }\n  }\n  return parent\n}\n\nfunction hasFullWidth (node: Node, nodes: Node[], overlapThreshold: number): boolean {\n  for (const other of nodes) {\n    if (other !== node &&\n      other.index > node.index &&\n      hasOverlap(node.start, addTime(node.start, overlapThreshold), other.start, other.end)) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction getGroups (visuals: CalendarEventVisual[], dayStart: number): Group[] {\n  const groups: Group[] = []\n\n  for (const visual of visuals) {\n    const [start, end] = getNormalizedRange(visual.event, dayStart)\n    let added = false\n\n    for (const group of groups) {\n      if (hasOverlap(start, end, group.start, group.end)) {\n        group.visuals.push(visual)\n        group.end = Math.max(group.end, end)\n        added = true\n        break\n      }\n    }\n\n    if (!added) {\n      groups.push({ start, end, visuals: [visual] })\n    }\n  }\n\n  return groups\n}\n\nfunction getNode (visual: CalendarEventVisual, dayStart: number): Node {\n  const [start, end] = getNormalizedRange(visual.event, dayStart)\n\n  return {\n    parent: null,\n    sibling: true,\n    index: 0,\n    visual,\n    start,\n    end,\n    children: [],\n  }\n}\n\nfunction getMaxChildIndex (node: Node): number {\n  let max = node.index\n  for (const child of node.children) {\n    const childMax = getMaxChildIndex(child)\n    if (childMax > max) {\n      max = childMax\n    }\n  }\n  return max\n}\n\nfunction addTime (identifier: number, minutes: number): number {\n  const removeMinutes = identifier % 100\n  const totalMinutes = removeMinutes + minutes\n  const addHours = Math.floor(totalMinutes / 60)\n  const addMinutes = totalMinutes % 60\n\n  return identifier - removeMinutes + addHours * 100 + addMinutes\n}\n"],"mappings":";;;;;;;AACA,SAASA,sBAAT,EAAiCC,UAAjC,EAA6CC,UAA7C,EAAyDC,kBAAzD,QAAmF,UAAnF;AACA,SAASC,sBAAT,QAAuC,mBAAvC;AAkBA,IAAMC,UAAU,GAAG,GAAnB;AAEA,IAAMC,cAAc,GAAG,CAAvB;AAEA,IAAMC,gBAAgB,GAAG,GAAzB;AAEA;;;;;;;;;;;;AAYG;;AAEH,OAAO,IAAMC,KAAK,GAA6B,SAAlCA,KAAKA,CAA8BC,MAAD,EAASC,YAAT,EAAuBC,gBAAvB,EAA2C;EACxF,IAAMC,OAAO,GAAGZ,sBAAsB,CAACU,YAAD,CAAtC,CADwF,CAGxF;;EACA,OAAO,UAACG,GAAD,EAAMC,SAAN,EAAiBC,KAAjB,EAAwBC,KAAxB,EAAiC;IACtC,IAAI,CAACD,KAAL,EAAY;MACV,OAAOH,OAAO,CAACX,UAAR,CAAmBY,GAAnB,EAAwBC,SAAxB,EAAmCC,KAAnC,EAA0CC,KAA1C,CAAP;IACD;IAED,IAAMC,QAAQ,GAAGb,sBAAsB,CAACS,GAAD,CAAvC;IACA,IAAMK,OAAO,GAAGjB,UAAU,CAACa,SAAD,EAAYG,QAAZ,CAA1B;IACA,IAAME,MAAM,GAAGC,SAAS,CAACF,OAAD,EAAUD,QAAV,CAAxB;IAAA,IAAAI,SAAA,GAAAC,0BAAA,CAEoBH,MAApB;MAAAI,KAAA;IAAA;MAAA,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA4B;QAAA,IAAjBC,KAAX,GAAAJ,KAAA,CAAAK,KAAA;QACE,IAAMC,KAAK,GAAW,EAAtB;QAAA,IAAAC,UAAA,GAAAR,0BAAA,CAEqBK,KAAK,CAACT,OAA3B;UAAAa,MAAA;QAAA;UAAA,KAAAD,UAAA,CAAAN,CAAA,MAAAO,MAAA,GAAAD,UAAA,CAAAL,CAAA,IAAAC,IAAA,GAAoC;YAAA,IAAzBM,MAAX,GAAAD,MAAA,CAAAH,KAAA;YACE,IAAMK,KAAK,GAAGC,OAAO,CAACF,MAAD,EAASf,QAAT,CAArB;YACA,IAAMkB,KAAK,GAAGC,YAAY,CAACH,KAAD,EAAQJ,KAAR,CAA1B;YAEA,IAAIM,KAAK,KAAK,KAAd,EAAqB;cACnB,IAAME,MAAM,GAAGC,SAAS,CAACL,KAAD,EAAQJ,KAAR,CAAxB;cACA,IAAIQ,MAAJ,EAAY;gBACVJ,KAAK,CAACI,MAAN,GAAeA,MAAf;gBACAJ,KAAK,CAACM,OAAN,GAAgBrC,UAAU,CAAC+B,KAAK,CAACO,KAAP,EAAcP,KAAK,CAACQ,GAApB,EAAyBJ,MAAM,CAACG,KAAhC,EAAuCE,OAAO,CAACL,MAAM,CAACG,KAAR,EAAe7B,gBAAf,CAA9C,CAA1B;gBACAsB,KAAK,CAACE,KAAN,GAAcE,MAAM,CAACF,KAAP,GAAe,CAA7B;gBACAE,MAAM,CAACM,QAAP,CAAgBC,IAAhB,CAAqBX,KAArB;cACD;YACF,CARD,MAQO;cACL,IAAAY,oBAAA,GAAiBC,mBAAmB,CAACb,KAAD,EAAQJ,KAAR,EAAeM,KAAK,GAAG,CAAvB,EAA0BA,KAAK,GAAG,CAAlC,CAApC;gBAAAY,qBAAA,GAAAC,cAAA,CAAAH,oBAAA;gBAAOR,OAAD,GAAAU,qBAAA;cACN,IAAMJ,QAAQ,GAAGG,mBAAmB,CAACb,KAAD,EAAQJ,KAAR,EAAeM,KAAK,GAAG,CAAvB,EAA0BA,KAAK,GAAGN,KAAK,CAACoB,MAAxC,EAAgD,IAAhD,CAApC;cAEAhB,KAAK,CAACU,QAAN,GAAiBA,QAAjB;cACAV,KAAK,CAACE,KAAN,GAAcA,KAAd;cAEA,IAAIE,OAAJ,EAAY;gBACVJ,KAAK,CAACI,MAAN,GAAeA,OAAf;gBACAJ,KAAK,CAACM,OAAN,GAAgBrC,UAAU,CAAC+B,KAAK,CAACO,KAAP,EAAcP,KAAK,CAACQ,GAApB,EAAyBJ,OAAM,CAACG,KAAhC,EAAuCE,OAAO,CAACL,OAAM,CAACG,KAAR,EAAe7B,gBAAf,CAA9C,CAA1B;gBACA0B,OAAM,CAACM,QAAP,CAAgBC,IAAhB,CAAqBX,KAArB;cACD;cAAA,IAAAiB,UAAA,GAAA5B,0BAAA,CAEmBqB,QAApB;gBAAAQ,MAAA;cAAA;gBAAA,KAAAD,UAAA,CAAA1B,CAAA,MAAA2B,MAAA,GAAAD,UAAA,CAAAzB,CAAA,IAAAC,IAAA,GAA8B;kBAAA,IAAnB0B,KAAX,GAAAD,MAAA,CAAAvB,KAAA;kBACE,IAAIwB,KAAK,CAACf,MAAN,KAAiBA,OAArB,EAA6B;oBAC3Be,KAAK,CAACf,MAAN,GAAeJ,KAAf;kBACD;kBAED,IAAMoB,SAAS,GAAGD,KAAK,CAACjB,KAAN,GAAcF,KAAK,CAACE,KAApB,IAA6B,CAA/C;kBACA,IAAIkB,SAAS,IAAIpB,KAAK,CAACM,OAAnB,IACFrC,UAAU,CAAC+B,KAAK,CAACO,KAAP,EAAcE,OAAO,CAACT,KAAK,CAACO,KAAP,EAAc7B,gBAAd,CAArB,EAAsDyC,KAAK,CAACZ,KAA5D,EAAmEY,KAAK,CAACX,GAAzE,CADZ,EAC2F;oBACzFW,KAAK,CAACb,OAAN,GAAgB,IAAhB;kBACD;gBACF;cAAA,SAAAe,GAAA;gBAAAJ,UAAA,CAAAK,CAAA,CAAAD,GAAA;cAAA;gBAAAJ,UAAA,CAAAM,CAAA;cAAA;YACF;YAED3B,KAAK,CAACe,IAAN,CAAWX,KAAX;UACD;QAAA,SAAAqB,GAAA;UAAAxB,UAAA,CAAAyB,CAAA,CAAAD,GAAA;QAAA;UAAAxB,UAAA,CAAA0B,CAAA;QAAA;QAEDC,eAAe,CAAC5B,KAAD,EAAQlB,gBAAR,CAAf;MACD;IAAA,SAAA2C,GAAA;MAAAjC,SAAA,CAAAkC,CAAA,CAAAD,GAAA;IAAA;MAAAjC,SAAA,CAAAmC,CAAA;IAAA;IAEDtC,OAAO,CAACwC,IAAR,CAAa,UAACC,CAAD,EAAIC,CAAJ;MAAA,OAAWD,CAAC,CAACE,IAAF,GAASD,CAAC,CAACC,IAAZ,IAAsBF,CAAC,CAACG,KAAF,CAAQC,wBAAR,GAAmCH,CAAC,CAACE,KAAF,CAAQC,wBAAxF;IAAA;IAEA,OAAO7C,OAAP;EACD,CA3DD;AA4DD,CAhEM;AAkEP,SAASuC,eAATA,CAA0B5B,KAA1B,EAAyClB,gBAAzC,EAAiE;EAAA,IAAAqD,UAAA,GAAA1C,0BAAA,CAC5CO,KAAnB;IAAAoC,MAAA;EAAA;IAAA,KAAAD,UAAA,CAAAxC,CAAA,MAAAyC,MAAA,GAAAD,UAAA,CAAAvC,CAAA,IAAAC,IAAA,GAA0B;MAAA,IAAfwC,IAAX,GAAAD,MAAA,CAAArC,KAAA;MACE,IAAQI,MAAF,GAAqBkC,IAA3B,CAAQlC,MAAF;QAAUK,MAAA,GAAW6B,IAA3B,CAAgB7B,MAAA;MAChB,IAAM8B,OAAO,GAAGC,gBAAgB,CAACF,IAAD,CAAhB,GAAyB,CAAzC;MACA,IAAMG,SAAS,GAAGhC,MAAM,GAAGA,MAAM,CAACL,MAAP,CAAc6B,IAAjB,GAAwB,CAAhD;MACA,IAAMS,UAAU,GAAGjE,UAAU,GAAGgE,SAAhC;MACA,IAAME,MAAM,GAAGC,IAAI,CAACC,GAAL,CAASnE,cAAT,EAAyBD,UAAU,GAAG8D,OAAtC,CAAf;MACA,IAAMO,qBAAqB,GAAGC,wBAAwB,CAACT,IAAD,EAAOrC,KAAP,CAAtD;MACA,IAAM+C,YAAY,GAAGN,UAAU,IAAIH,OAAO,GAAGD,IAAI,CAAC/B,KAAf,GAAuB,CAA3B,CAA/B;MACA,IAAM0C,WAAW,GAAGP,UAAU,IAAIH,OAAO,GAAGD,IAAI,CAAC/B,KAAf,IAAwB+B,IAAI,CAAC3B,OAAL,GAAe,CAAf,GAAmB,CAA3C,CAAJ,CAAV,GAA+DmC,qBAAnF;MAEA,IAAIrC,MAAJ,EAAY;QACVL,MAAM,CAAC6B,IAAP,GAAcK,IAAI,CAAC3B,OAAL,GACV8B,SAAS,GAAGO,YADF,GAEVP,SAAS,GAAGE,MAFhB;MAGD;MAEDvC,MAAM,CAAC8C,KAAP,GAAeC,YAAY,CAACb,IAAD,EAAOrC,KAAP,EAAclB,gBAAd,CAAZ,GACXN,UAAU,GAAG2B,MAAM,CAAC6B,IADT,GAEXW,IAAI,CAACC,GAAL,CAASpE,UAAU,GAAG2B,MAAM,CAAC6B,IAA7B,EAAmCgB,WAAW,GAAGtE,gBAAjD,CAFJ;IAGD;EAAA,SAAA+C,GAAA;IAAAU,UAAA,CAAAT,CAAA,CAAAD,GAAA;EAAA;IAAAU,UAAA,CAAAR,CAAA;EAAA;AACF;AAED,SAASmB,wBAATA,CAAmCT,IAAnC,EAA+CrC,KAA/C,EAA4D;EAC1D,IAAI,CAACqC,IAAI,CAACvB,QAAL,CAAcM,MAAnB,EAA2B;IACzB,OAAO,CAAP;EACD;EAED,IAAM+B,SAAS,GAAGd,IAAI,CAAC/B,KAAL,GAAaN,KAAK,CAACoB,MAArC;EACA,IAAMgC,SAAS,GAAGf,IAAI,CAACvB,QAAL,CAAcuC,MAAd,CAAqB,UAACT,GAAD,EAAMU,CAAN;IAAA,OAAYX,IAAI,CAACC,GAAL,CAASA,GAAT,EAAcU,CAAC,CAAChD,KAAhB,CAAjC;EAAA,GAAyD6C,SAAzD,CAAlB;EAEA,OAAOC,SAAS,GAAGf,IAAI,CAAC/B,KAAxB;AACD;AAED,SAASiD,qBAATA,CAAgClB,IAAhC,EAA4CrC,KAA5C,EAAyD;EACvD,IAAMwD,OAAO,GAAa,EAA1B;EAAA,IAAAC,UAAA,GAAAhE,0BAAA,CACoBO,KAApB;IAAA0D,MAAA;EAAA;IAAA,KAAAD,UAAA,CAAA9D,CAAA,MAAA+D,MAAA,GAAAD,UAAA,CAAA7D,CAAA,IAAAC,IAAA,GAA2B;MAAA,IAAhB8D,KAAX,GAAAD,MAAA,CAAA3D,KAAA;MACE,IAAI1B,UAAU,CAACgE,IAAI,CAAC1B,KAAN,EAAa0B,IAAI,CAACzB,GAAlB,EAAuB+C,KAAK,CAAChD,KAA7B,EAAoCgD,KAAK,CAAC/C,GAA1C,CAAd,EAA8D;QAC5D4C,OAAO,CAACzC,IAAR,CAAa4C,KAAK,CAACrD,KAAnB;MACD;IACF;EAAA,SAAAmB,GAAA;IAAAgC,UAAA,CAAA/B,CAAA,CAAAD,GAAA;EAAA;IAAAgC,UAAA,CAAA9B,CAAA;EAAA;EACD,OAAO6B,OAAP;AACD;AAED,SAASjD,YAATA,CAAuB8B,IAAvB,EAAmCrC,KAAnC,EAAgD;EAC9C,IAAMwD,OAAO,GAAGD,qBAAqB,CAAClB,IAAD,EAAOrC,KAAP,CAArC;EACAwD,OAAO,CAAC3B,IAAR;EAEA,KAAK,IAAI+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,OAAO,CAACpC,MAA5B,EAAoCwC,CAAC,EAArC,EAAyC;IACvC,IAAIA,CAAC,GAAGJ,OAAO,CAACI,CAAD,CAAf,EAAoB;MAClB,OAAOA,CAAP;IACD;EACF;EACD,OAAO,KAAP;AACD;AAED,SAAS3C,mBAATA,CAA8BoB,IAA9B,EAA0CrC,KAA1C,EAAyD6D,QAAzD,EAA2EC,QAA3E,EAAsH;EAAA,IAAzBC,iBAAiB,GAAAC,SAAA,CAAA5C,MAAA,QAAA4C,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAjH;EACE,IAAME,WAAW,GAAW,EAA5B;EAAA,IAAAC,UAAA,GAAA1E,0BAAA,CACoBO,KAApB;IAAAoE,MAAA;EAAA;IAAA,KAAAD,UAAA,CAAAxE,CAAA,MAAAyE,MAAA,GAAAD,UAAA,CAAAvE,CAAA,IAAAC,IAAA,GAA2B;MAAA,IAAhB8D,KAAX,GAAAS,MAAA,CAAArE,KAAA;MACE,IAAI4D,KAAK,CAACrD,KAAN,IAAeuD,QAAf,IAA2BF,KAAK,CAACrD,KAAN,IAAewD,QAA1C,IAAsDzF,UAAU,CAACgE,IAAI,CAAC1B,KAAN,EAAa0B,IAAI,CAACzB,GAAlB,EAAuB+C,KAAK,CAAChD,KAA7B,EAAoCgD,KAAK,CAAC/C,GAA1C,CAApE,EAAoH;QAClHsD,WAAW,CAACnD,IAAZ,CAAiB4C,KAAjB;MACD;IACF;EAAA,SAAAlC,GAAA;IAAA0C,UAAA,CAAAzC,CAAA,CAAAD,GAAA;EAAA;IAAA0C,UAAA,CAAAxC,CAAA;EAAA;EACD,IAAIoC,iBAAiB,IAAIG,WAAW,CAAC9C,MAAZ,GAAqB,CAA9C,EAAiD;IAC/C,IAAMiD,KAAK,GAAGH,WAAW,CAACb,MAAZ,CAAmB,UAACT,GAAD,EAAMhD,CAAN;MAAA,OAAY+C,IAAI,CAACC,GAAL,CAASA,GAAT,EAAchD,CAAC,CAACU,KAAhB,CAA/B;IAAA,GAAuD4D,WAAW,CAAC,CAAD,CAAX,CAAe5D,KAAtE,CAAd;IACA,OAAO4D,WAAW,CAACI,MAAZ,CAAmB,UAAA1E,CAAC;MAAA,OAAIA,CAAC,CAACU,KAAF,KAAY+D,KAApC;IAAA,EAAP;EACD;EACD,OAAOH,WAAP;AACD;AAED,SAASzD,SAATA,CAAoB4B,IAApB,EAAgCrC,KAAhC,EAA6C;EAC3C,IAAIQ,MAAM,GAAgB,IAA1B;EAAA,IAAA+D,UAAA,GAAA9E,0BAAA,CACoBO,KAApB;IAAAwE,MAAA;EAAA;IAAA,KAAAD,UAAA,CAAA5E,CAAA,MAAA6E,MAAA,GAAAD,UAAA,CAAA3E,CAAA,IAAAC,IAAA,GAA2B;MAAA,IAAhB8D,KAAX,GAAAa,MAAA,CAAAzE,KAAA;MACE,IAAI1B,UAAU,CAACgE,IAAI,CAAC1B,KAAN,EAAa0B,IAAI,CAACzB,GAAlB,EAAuB+C,KAAK,CAAChD,KAA7B,EAAoCgD,KAAK,CAAC/C,GAA1C,CAAV,KAA6DJ,MAAM,KAAK,IAAX,IAAmBmD,KAAK,CAACrD,KAAN,GAAcE,MAAM,CAACF,KAArG,CAAJ,EAAiH;QAC/GE,MAAM,GAAGmD,KAAT;MACD;IACF;EAAA,SAAAlC,GAAA;IAAA8C,UAAA,CAAA7C,CAAA,CAAAD,GAAA;EAAA;IAAA8C,UAAA,CAAA5C,CAAA;EAAA;EACD,OAAOnB,MAAP;AACD;AAED,SAAS0C,YAATA,CAAuBb,IAAvB,EAAmCrC,KAAnC,EAAkDlB,gBAAlD,EAA0E;EAAA,IAAA2F,UAAA,GAAAhF,0BAAA,CACpDO,KAApB;IAAA0E,MAAA;EAAA;IAAA,KAAAD,UAAA,CAAA9E,CAAA,MAAA+E,MAAA,GAAAD,UAAA,CAAA7E,CAAA,IAAAC,IAAA,GAA2B;MAAA,IAAhB8D,KAAX,GAAAe,MAAA,CAAA3E,KAAA;MACE,IAAI4D,KAAK,KAAKtB,IAAV,IACFsB,KAAK,CAACrD,KAAN,GAAc+B,IAAI,CAAC/B,KADjB,IAEFjC,UAAU,CAACgE,IAAI,CAAC1B,KAAN,EAAaE,OAAO,CAACwB,IAAI,CAAC1B,KAAN,EAAa7B,gBAAb,CAApB,EAAoD6E,KAAK,CAAChD,KAA1D,EAAiEgD,KAAK,CAAC/C,GAAvE,CAFZ,EAEyF;QACvF,OAAO,KAAP;MACD;IACF;EAAA,SAAAa,GAAA;IAAAgD,UAAA,CAAA/C,CAAA,CAAAD,GAAA;EAAA;IAAAgD,UAAA,CAAA9C,CAAA;EAAA;EAED,OAAO,IAAP;AACD;AAED,SAASpC,SAATA,CAAoBF,OAApB,EAAoDD,QAApD,EAAoE;EAClE,IAAME,MAAM,GAAY,EAAxB;EAAA,IAAAqF,UAAA,GAAAlF,0BAAA,CAEqBJ,OAArB;IAAAuF,MAAA;EAAA;IAAA,KAAAD,UAAA,CAAAhF,CAAA,MAAAiF,MAAA,GAAAD,UAAA,CAAA/E,CAAA,IAAAC,IAAA,GAA8B;MAAA,IAAnBM,MAAX,GAAAyE,MAAA,CAAA7E,KAAA;MACE,IAAA8E,mBAAA,GAAqBvG,kBAAkB,CAAC6B,MAAM,CAAC8B,KAAR,EAAe7C,QAAf,CAAvC;QAAA0F,oBAAA,GAAA3D,cAAA,CAAA0D,mBAAA;QAAOlE,KAAD,GAAAmE,oBAAA;QAAQlE,GAAR,GAAAkE,oBAAA;MACN,IAAIC,KAAK,GAAG,KAAZ;MAAA,IAAAC,WAAA,GAAAvF,0BAAA,CAEoBH,MAApB;QAAA2F,OAAA;MAAA;QAAA,KAAAD,WAAA,CAAArF,CAAA,MAAAsF,OAAA,GAAAD,WAAA,CAAApF,CAAA,IAAAC,IAAA,GAA4B;UAAA,IAAjBC,KAAX,GAAAmF,OAAA,CAAAlF,KAAA;UACE,IAAI1B,UAAU,CAACsC,KAAD,EAAQC,GAAR,EAAad,KAAK,CAACa,KAAnB,EAA0Bb,KAAK,CAACc,GAAhC,CAAd,EAAoD;YAClDd,KAAK,CAACT,OAAN,CAAc0B,IAAd,CAAmBZ,MAAnB;YACAL,KAAK,CAACc,GAAN,GAAY+B,IAAI,CAACuC,GAAL,CAASpF,KAAK,CAACc,GAAf,EAAoBA,GAApB,CAAZ;YACAmE,KAAK,GAAG,IAAR;YACA;UACD;QACF;MAAA,SAAAtD,GAAA;QAAAuD,WAAA,CAAAtD,CAAA,CAAAD,GAAA;MAAA;QAAAuD,WAAA,CAAArD,CAAA;MAAA;MAED,IAAI,CAACoD,KAAL,EAAY;QACVzF,MAAM,CAACyB,IAAP,CAAY;UAAEJ,KAAF,EAAEA,KAAF;UAASC,GAAT,EAASA,GAAT;UAAcvB,OAAO,EAAE,CAACc,MAAD;QAAvB,CAAZ;MACD;IACF;EAAA,SAAAsB,GAAA;IAAAkD,UAAA,CAAAjD,CAAA,CAAAD,GAAA;EAAA;IAAAkD,UAAA,CAAAhD,CAAA;EAAA;EAED,OAAOrC,MAAP;AACD;AAED,SAASe,OAATA,CAAkBF,MAAlB,EAA+Cf,QAA/C,EAA+D;EAC7D,IAAA+F,oBAAA,GAAqB7G,kBAAkB,CAAC6B,MAAM,CAAC8B,KAAR,EAAe7C,QAAf,CAAvC;IAAAgG,oBAAA,GAAAjE,cAAA,CAAAgE,oBAAA;IAAOxE,KAAD,GAAAyE,oBAAA;IAAQxE,GAAR,GAAAwE,oBAAA;EAEN,OAAO;IACL5E,MAAM,EAAE,IADH;IAELE,OAAO,EAAE,IAFJ;IAGLJ,KAAK,EAAE,CAHF;IAILH,MAJK,EAILA,MAJK;IAKLQ,KALK,EAKLA,KALK;IAMLC,GANK,EAMLA,GANK;IAOLE,QAAQ,EAAE;EAPL,CAAP;AASD;AAED,SAASyB,gBAATA,CAA2BF,IAA3B,EAAqC;EACnC,IAAI6C,GAAG,GAAG7C,IAAI,CAAC/B,KAAf;EAAA,IAAA+E,WAAA,GAAA5F,0BAAA,CACoB4C,IAAI,CAACvB,QAAzB;IAAAwE,OAAA;EAAA;IAAA,KAAAD,WAAA,CAAA1F,CAAA,MAAA2F,OAAA,GAAAD,WAAA,CAAAzF,CAAA,IAAAC,IAAA,GAAmC;MAAA,IAAxBO,KAAX,GAAAkF,OAAA,CAAAvF,KAAA;MACE,IAAMwF,QAAQ,GAAGhD,gBAAgB,CAACnC,KAAD,CAAjC;MACA,IAAImF,QAAQ,GAAGL,GAAf,EAAoB;QAClBA,GAAG,GAAGK,QAAN;MACD;IACF;EAAA,SAAA9D,GAAA;IAAA4D,WAAA,CAAA3D,CAAA,CAAAD,GAAA;EAAA;IAAA4D,WAAA,CAAA1D,CAAA;EAAA;EACD,OAAOuD,GAAP;AACD;AAED,SAASrE,OAATA,CAAkB2E,UAAlB,EAAsCC,OAAtC,EAAqD;EACnD,IAAMC,aAAa,GAAGF,UAAU,GAAG,GAAnC;EACA,IAAMG,YAAY,GAAGD,aAAa,GAAGD,OAArC;EACA,IAAMG,QAAQ,GAAGjD,IAAI,CAACkD,KAAL,CAAWF,YAAY,GAAG,EAA1B,CAAjB;EACA,IAAMG,UAAU,GAAGH,YAAY,GAAG,EAAlC;EAEA,OAAOH,UAAU,GAAGE,aAAb,GAA6BE,QAAQ,GAAG,GAAxC,GAA8CE,UAArD;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}