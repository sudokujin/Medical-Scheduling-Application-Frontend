{"ast":null,"code":"import _slicedToArray from \"/Users/kwon/Desktop/repo/Medical-Scheduling-Application-Frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { getTimestampIdentifier } from '../util/timestamp';\nvar MILLIS_IN_DAY = 86400000;\nfunction _getVisuals(events) {\n  var minStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var visuals = events.map(function (event) {\n    return {\n      event: event,\n      columnCount: 0,\n      column: 0,\n      left: 0,\n      width: 100\n    };\n  });\n  visuals.sort(function (a, b) {\n    return Math.max(minStart, a.event.startTimestampIdentifier) - Math.max(minStart, b.event.startTimestampIdentifier) || b.event.endTimestampIdentifier - a.event.endTimestampIdentifier;\n  });\n  return visuals;\n}\nexport { _getVisuals as getVisuals };\nexport function hasOverlap(s0, e0, s1, e1) {\n  var exclude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  return exclude ? !(s0 >= e1 || e0 <= s1) : !(s0 > e1 || e0 < s1);\n}\nexport function setColumnCount(groups) {\n  groups.forEach(function (group) {\n    group.visuals.forEach(function (groupVisual) {\n      groupVisual.columnCount = groups.length;\n    });\n  });\n}\nexport function getRange(event) {\n  return [event.startTimestampIdentifier, event.endTimestampIdentifier];\n}\nexport function getDayRange(event) {\n  return [event.startIdentifier, event.endIdentifier];\n}\nexport function getNormalizedRange(event, dayStart) {\n  return [Math.max(dayStart, event.startTimestampIdentifier), Math.min(dayStart + MILLIS_IN_DAY, event.endTimestampIdentifier)];\n}\nexport function getOpenGroup(groups, start, end, timed) {\n  for (var i = 0; i < groups.length; i++) {\n    var group = groups[i];\n    var intersected = false;\n    if (hasOverlap(start, end, group.start, group.end, timed)) {\n      for (var k = 0; k < group.visuals.length; k++) {\n        var groupVisual = group.visuals[k];\n        var _ref = timed ? getRange(groupVisual.event) : getDayRange(groupVisual.event),\n          _ref2 = _slicedToArray(_ref, 2),\n          groupStart = _ref2[0],\n          groupEnd = _ref2[1];\n        if (hasOverlap(start, end, groupStart, groupEnd, timed)) {\n          intersected = true;\n          break;\n        }\n      }\n    }\n    if (!intersected) {\n      return i;\n    }\n  }\n  return -1;\n}\nexport function getOverlapGroupHandler(firstWeekday) {\n  var handler = {\n    groups: [],\n    min: -1,\n    max: -1,\n    reset: function reset() {\n      handler.groups = [];\n      handler.min = handler.max = -1;\n    },\n    getVisuals: function getVisuals(day, dayEvents, timed) {\n      var reset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      if (day.weekday === firstWeekday || reset) {\n        handler.reset();\n      }\n      var dayStart = getTimestampIdentifier(day);\n      var visuals = _getVisuals(dayEvents, dayStart);\n      visuals.forEach(function (visual) {\n        var _ref3 = timed ? getRange(visual.event) : getDayRange(visual.event),\n          _ref4 = _slicedToArray(_ref3, 2),\n          start = _ref4[0],\n          end = _ref4[1];\n        if (handler.groups.length > 0 && !hasOverlap(start, end, handler.min, handler.max, timed)) {\n          setColumnCount(handler.groups);\n          handler.reset();\n        }\n        var targetGroup = getOpenGroup(handler.groups, start, end, timed);\n        if (targetGroup === -1) {\n          targetGroup = handler.groups.length;\n          handler.groups.push({\n            start: start,\n            end: end,\n            visuals: []\n          });\n        }\n        var target = handler.groups[targetGroup];\n        target.visuals.push(visual);\n        target.start = Math.min(target.start, start);\n        target.end = Math.max(target.end, end);\n        visual.column = targetGroup;\n        if (handler.min === -1) {\n          handler.min = start;\n          handler.max = end;\n        } else {\n          handler.min = Math.min(handler.min, start);\n          handler.max = Math.max(handler.max, end);\n        }\n      });\n      setColumnCount(handler.groups);\n      if (timed) {\n        handler.reset();\n      }\n      return visuals;\n    }\n  };\n  return handler;\n}","map":{"version":3,"names":["getTimestampIdentifier","MILLIS_IN_DAY","getVisuals","events","minStart","arguments","length","undefined","visuals","map","event","columnCount","column","left","width","sort","a","b","Math","max","startTimestampIdentifier","endTimestampIdentifier","_getVisuals","hasOverlap","s0","e0","s1","e1","exclude","setColumnCount","groups","forEach","group","groupVisual","getRange","getDayRange","startIdentifier","endIdentifier","getNormalizedRange","dayStart","min","getOpenGroup","start","end","timed","i","intersected","k","_ref","_ref2","_slicedToArray","groupStart","groupEnd","getOverlapGroupHandler","firstWeekday","handler","reset","day","dayEvents","weekday","visual","_ref3","_ref4","targetGroup","push","target"],"sources":["../../../../src/components/VCalendar/modes/common.ts"],"sourcesContent":["import { CalendarEventParsed, CalendarEventVisual, CalendarTimestamp } from 'vuetify/types'\nimport { getTimestampIdentifier } from '../util/timestamp'\n\nconst MILLIS_IN_DAY = 86400000\n\nexport type GetRange = (event: CalendarEventParsed) => [number, number]\n\nexport function getVisuals (events: CalendarEventParsed[], minStart = 0): CalendarEventVisual[] {\n  const visuals = events.map(event => ({\n    event,\n    columnCount: 0,\n    column: 0,\n    left: 0,\n    width: 100,\n  }))\n\n  visuals.sort((a, b) => {\n    return (Math.max(minStart, a.event.startTimestampIdentifier) - Math.max(minStart, b.event.startTimestampIdentifier)) ||\n           (b.event.endTimestampIdentifier - a.event.endTimestampIdentifier)\n  })\n\n  return visuals\n}\n\nexport interface ColumnGroup {\n  start: number\n  end: number\n  visuals: CalendarEventVisual[]\n}\n\nexport function hasOverlap (s0: number, e0: number, s1: number, e1: number, exclude = true): boolean {\n  return exclude ? !(s0 >= e1 || e0 <= s1) : !(s0 > e1 || e0 < s1)\n}\n\nexport function setColumnCount (groups: ColumnGroup[]) {\n  groups.forEach(group => {\n    group.visuals.forEach(groupVisual => {\n      groupVisual.columnCount = groups.length\n    })\n  })\n}\n\nexport function getRange (event: CalendarEventParsed): [number, number] {\n  return [event.startTimestampIdentifier, event.endTimestampIdentifier]\n}\n\nexport function getDayRange (event: CalendarEventParsed): [number, number] {\n  return [event.startIdentifier, event.endIdentifier]\n}\n\nexport function getNormalizedRange (event: CalendarEventParsed, dayStart: number): [number, number] {\n  return [Math.max(dayStart, event.startTimestampIdentifier), Math.min(dayStart + MILLIS_IN_DAY, event.endTimestampIdentifier)]\n}\n\nexport function getOpenGroup (groups: ColumnGroup[], start: number, end: number, timed: boolean) {\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i]\n    let intersected = false\n\n    if (hasOverlap(start, end, group.start, group.end, timed)) {\n      for (let k = 0; k < group.visuals.length; k++) {\n        const groupVisual = group.visuals[k]\n        const [groupStart, groupEnd] = timed ? getRange(groupVisual.event) : getDayRange(groupVisual.event)\n\n        if (hasOverlap(start, end, groupStart, groupEnd, timed)) {\n          intersected = true\n          break\n        }\n      }\n    }\n\n    if (!intersected) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport function getOverlapGroupHandler (firstWeekday: number) {\n  const handler = {\n    groups: [] as ColumnGroup[],\n    min: -1,\n    max: -1,\n    reset: () => {\n      handler.groups = []\n      handler.min = handler.max = -1\n    },\n    getVisuals: (day: CalendarTimestamp, dayEvents: CalendarEventParsed[], timed: boolean, reset = false) => {\n      if (day.weekday === firstWeekday || reset) {\n        handler.reset()\n      }\n\n      const dayStart = getTimestampIdentifier(day)\n      const visuals = getVisuals(dayEvents, dayStart)\n\n      visuals.forEach(visual => {\n        const [start, end] = timed ? getRange(visual.event) : getDayRange(visual.event)\n\n        if (handler.groups.length > 0 && !hasOverlap(start, end, handler.min, handler.max, timed)) {\n          setColumnCount(handler.groups)\n          handler.reset()\n        }\n\n        let targetGroup = getOpenGroup(handler.groups, start, end, timed)\n\n        if (targetGroup === -1) {\n          targetGroup = handler.groups.length\n\n          handler.groups.push({ start, end, visuals: [] })\n        }\n\n        const target = handler.groups[targetGroup]\n        target.visuals.push(visual)\n        target.start = Math.min(target.start, start)\n        target.end = Math.max(target.end, end)\n\n        visual.column = targetGroup\n\n        if (handler.min === -1) {\n          handler.min = start\n          handler.max = end\n        } else {\n          handler.min = Math.min(handler.min, start)\n          handler.max = Math.max(handler.max, end)\n        }\n      })\n\n      setColumnCount(handler.groups)\n\n      if (timed) {\n        handler.reset()\n      }\n\n      return visuals\n    },\n  }\n\n  return handler\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}